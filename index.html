<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Conversation with Pollinations</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #202020;
      color: #ffffff;
      text-align: center;
    }
    .chat-container {
      max-width: 80%;
      margin: 20px auto;
      background-color: #333333;
      border-radius: 5px;
      padding: 10px;
      text-align: left;
      max-height: 400px;
      overflow-y: auto;
    }
    .message {
      margin: 10px 0;
      padding: 10px;
      border-radius: 5px;
    }
    .user {
      background-color: #555555;
      text-align: right;
    }
    .ai {
      background-color: #777777;
      text-align: left;
    }
    #status, #errorMsg {
      font-size: 16px;
      margin-top: 10px;
      padding: 5px;
      background-color: #222;
      border-radius: 5px;
    }
    button {
      margin: 10px;
      padding: 10px 20px;
      font-size: 16px;
      background-color: #333333;
      color: #ffffff;
      border: 1px solid #555555;
      border-radius: 5px;
      cursor: pointer;
    }
    button:hover {
      background-color: #c4c4c4;
    }
    select, input[type="range"], input[type="text"] {
      margin: 10px;
      padding: 10px;
      font-size: 16px;
      background-color: #333333;
      color: #ffffff;
      border: 1px solid #555555;
      border-radius: 5px;
    }
    .toggle-container, .settings-container, .control-container {
      margin: 20px;
      font-size: 16px;
    }
    label {
      margin-right: 10px;
    }
    /* New styles for text input container */
    .text-input-container {
      max-width: 80%;
      margin: 10px auto;
      display: flex;
      justify-content: center;
    }
    .text-input-container input {
      flex: 1;
    }
  </style>
</head>
<body>
  <h1>AI Conversation with Pollinations</h1>
  
  <div class="control-container">
    <button id="startBtn">Start Conversation</button>
    <button id="stopBtn" disabled>Stop Conversation</button>
    <label for="webSearchToggle">Enable Web Search</label>
    <input type="checkbox" id="webSearchToggle">
    <button id="stopTTSBtn" disabled>Stop TTS</button>
    <button id="clearBtn">Clear Conversation</button>
    <button id="resetStorageBtn">Reset Settings</button>
  </div>

  <div class="control-container">
    <!-- Voice Selection -->
    <select id="voiceSelect"></select>
    <!-- Chat Model Selection -->
    <select id="modelSelect">
      <!-- Options will be populated dynamically from Pollinations models -->
    </select>
  </div>

  <div class="settings-container">
    <label for="pitchRange">Pitch:</label>
    <input type="range" id="pitchRange" min="0" max="2" step="0.1" value="1">
    <span id="pitchValue">1</span>
    <br>
    <label for="rateRange">Rate:</label>
    <input type="range" id="rateRange" min="0.5" max="2" step="0.1" value="1">
    <span id="rateValue">1</span>
  </div>

  <div class="toggle-container">
    <label>
      <input type="checkbox" id="interruptToggle" checked>
      Allow TTS Interruption
    </label>
  </div>

  <div id="status">Status messages will appear here...</div>
  <div id="errorMsg"></div>
  
  <!-- Chat history container -->
  <div class="chat-container" id="chatHistory">
    <!-- Chat messages will be appended here -->
  </div>
  
  <!-- New Text Input Container -->
  <div class="text-input-container">
    <input type="text" id="textInput" placeholder="Type your message here..." />
    <button id="sendBtn">Send</button>
  </div>

  <script>
    let recognition;
    let isListening = false;
    let currentUtterance = null;
    let isTTSActive = false; // Flag for TTS activity
    let lastErrorWasNoSpeech = false; // Flag for no-speech error
    
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const stopTTSBtn = document.getElementById('stopTTSBtn');
    const clearBtn = document.getElementById('clearBtn');
    const resetStorageBtn = document.getElementById('resetStorageBtn');
    const statusDiv = document.getElementById('status');
    const errorMsgDiv = document.getElementById('errorMsg');
    const chatHistory = document.getElementById('chatHistory');
    const voiceSelect = document.getElementById('voiceSelect');
    const modelSelect = document.getElementById('modelSelect');
    const interruptToggle = document.getElementById('interruptToggle');
    const pitchRange = document.getElementById('pitchRange');
    const rateRange = document.getElementById('rateRange');
    const pitchValue = document.getElementById('pitchValue');
    const rateValue = document.getElementById('rateValue');
    const textInput = document.getElementById('textInput');
    const sendBtn = document.getElementById('sendBtn');

    // Update pitch and rate display and save to localStorage
    pitchRange.addEventListener('input', () => {
      pitchValue.innerText = pitchRange.value;
      localStorage.setItem('pitch', pitchRange.value);
    });
    rateRange.addEventListener('input', () => {
      rateValue.innerText = rateRange.value;
      localStorage.setItem('rate', rateRange.value);
    });

    // Initialize saved settings
    function loadSettings() {
      const savedPitch = localStorage.getItem('pitch');
      if (savedPitch) {
        pitchRange.value = savedPitch;
        pitchValue.innerText = savedPitch;
      }
      const savedRate = localStorage.getItem('rate');
      if (savedRate) {
        rateRange.value = savedRate;
        rateValue.innerText = savedRate;
      }
    }

    // Function to dynamically load models from Pollinations and populate the modelSelect dropdown.
    async function loadModels() {
      try {
        const response = await fetch("https://text.pollinations.ai/models");
        const models = await response.json();
        let optionsHtml = "";
        models.forEach(model => {
          // Use the description as the display text.
          let optionText = model.description;
          // Append "(uncensored)" if the model is uncensored.
          if (model.censored === false) {
            optionText += " (uncensored)";
          }
          optionsHtml += `<option value="${model.name}">${optionText}</option>`;
        });
        modelSelect.innerHTML = optionsHtml;
        console.log("Models loaded:", models);
      } catch (error) {
        console.error("Error loading models:", error);
        statusDiv.innerText = "Failed to load models.";
      }
    }

    // Append a message to the chat history
    function appendMessage(text, sender) {
      const messageElem = document.createElement('div');
      messageElem.classList.add('message');
      messageElem.classList.add(sender); // "user" or "ai"
      messageElem.innerText = text;
      chatHistory.appendChild(messageElem);
      chatHistory.scrollTop = chatHistory.scrollHeight;
    }

    // Clear conversation history
    clearBtn.addEventListener('click', () => {
      chatHistory.innerHTML = '';
      statusDiv.innerText = 'Conversation cleared.';
    });

    // Reset localStorage and reload settings
    resetStorageBtn.addEventListener('click', () => {
      localStorage.clear();
      loadSettings();
      loadModels();
      statusDiv.innerText = 'Settings have been reset.';
    });

    // Process text input (from typing)
    async function processTextInput() {
      const text = textInput.value.trim();
      if (text) {
        appendMessage("You: " + text, "user");
        statusDiv.innerText = "Processing your input...";
        console.log("Text input:", text);
        try {
          const aiResponse = await getAIResponse(text);
          appendMessage("AI: " + aiResponse, "ai");
          speak(aiResponse);
        } catch (error) {
          errorMsgDiv.innerText = "Error fetching AI response.";
        }
        textInput.value = ""; // Clear the input field
      }
    }

    // Add event listener for the Send button and Enter key on the text input
    sendBtn.addEventListener('click', processTextInput);
    textInput.addEventListener('keyup', (event) => {
      if (event.key === "Enter") {
        processTextInput();
      }
    });

    // Initialize Speech Recognition if supported
    if ("webkitSpeechRecognition" in window) {
      recognition = new webkitSpeechRecognition();
      recognition.lang = "en-US";
      recognition.continuous = true;
      recognition.interimResults = false;

      recognition.onstart = () => {
        statusDiv.innerText = "Speech Recognition Started.";
      };

      recognition.onerror = (event) => {
        console.error("Speech Recognition Error:", event.error);
        if (event.error !== "no-speech") {
          lastErrorWasNoSpeech = false;
          errorMsgDiv.innerText = "Speech Recognition Error: " + event.error;
          if (currentUtterance) {
            window.speechSynthesis.cancel();
            currentUtterance = null;
            isTTSActive = false;
            stopTTSBtn.disabled = true;
          }
        } else {
          lastErrorWasNoSpeech = true;
          console.log("No-speech error; TTS will continue.");
        }
      };

      recognition.onend = () => {
        statusDiv.innerText = "Speech Recognition Ended.";
        if (!isListening && currentUtterance) {
          window.speechSynthesis.cancel();
          currentUtterance = null;
          isTTSActive = false;
          stopTTSBtn.disabled = true;
        }
        if (isListening) {
          recognition.start();
        } else {
          startBtn.disabled = false;
          stopBtn.disabled = true;
        }
      };

      recognition.onresult = async (event) => {
        lastErrorWasNoSpeech = false;
        if (interruptToggle.checked && isTTSActive) {
          window.speechSynthesis.cancel();
          isTTSActive = false;
          currentUtterance = null;
          stopTTSBtn.disabled = true;
          statusDiv.innerText = "TTS interrupted by user speech.";
        }
        for (let i = event.resultIndex; i < event.results.length; i++) {
          if (event.results[i].isFinal) {
            let sentence = event.results[i][0].transcript.trim();
            if (sentence) {
              appendMessage("You: " + sentence, "user");
              statusDiv.innerText = "Processing your input...";
              console.log(`Finalized Sentence: ${sentence}`);
              try {
                const aiResponse = await getAIResponse(sentence);
                appendMessage("AI: " + aiResponse, "ai");
                speak(aiResponse);
              } catch (error) {
                errorMsgDiv.innerText = "Error fetching AI response.";
              }
            }
          }
        }
      };

      startBtn.addEventListener("click", () => {
        isListening = true;
        recognition.start();
        startBtn.disabled = true;
        stopBtn.disabled = false;
      });

      stopBtn.addEventListener("click", () => {
        isListening = false;
        recognition.stop();
        startBtn.disabled = false;
        stopBtn.disabled = true;
        statusDiv.innerText = "Speech Recognition stopped.";
      });

      stopTTSBtn.addEventListener("click", () => {
        if (currentUtterance) {
          currentUtterance.onend = null;
          window.speechSynthesis.cancel();
          currentUtterance = null;
          isTTSActive = false;
          stopTTSBtn.disabled = true;
          statusDiv.innerText = "TTS stopped.";
        }
      });
    } else {
      alert("Your browser does not support webkitSpeechRecognition.");
    }

    // Function to get AI response from Pollinations using the selected model,
    // enhanced with web search results if the toggle is enabled.
    async function getAIResponse(prompt) {
      console.log("Received prompt:", prompt);
      const model = modelSelect.value;
      const webSearchEnabled = document.getElementById('webSearchToggle').checked;
      let finalPrompt = prompt;
      
      if (webSearchEnabled) {
        try {
          let searchQuery = prompt;
          const searchResponse = await fetch(`https://api.duckduckgo.com/?q=${encodeURIComponent(searchQuery)}&format=json&no_html=1&skip_disambig=1`);
          const searchData = await searchResponse.json();
          console.log("DuckDuckGo API response:", searchData);

          let searchResults = searchData.AbstractText;
          if (!searchResults || searchResults.trim() === "") {
            if (searchData.RelatedTopics && searchData.RelatedTopics.length > 0) {
              searchResults = searchData.RelatedTopics.slice(0, 3)
                .map(rt => rt.Text)
                .join("\n");
            }
          }
          if (!searchResults || searchResults.trim() === "") {
            searchResults = "No additional information found.";
          }
          
          console.log("searchResults:", searchResults);
          finalPrompt = prompt + "\n\nUse the following web search summary to answer the question:\n" + searchResults;
          statusDiv.innerText = "Web search completed and combined with your prompt.";
        } catch (error) {
          console.error("Web search error:", error);
          statusDiv.innerText = "Web search failed; proceeding with original prompt.";
        }
      }

      console.log("Final prompt being sent to AI:", finalPrompt);
      
      const response = await fetch(`https://text.pollinations.ai/${model}/${encodeURIComponent(finalPrompt)}`);
      const data = await response.text();
      
      console.log("AI response data:", data);
      
      return data;
    }

    // Function to speak the AI response
    function speak(text) {
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.pitch = parseFloat(pitchRange.value);
      utterance.rate = parseFloat(rateRange.value);
      const selectedVoiceName = voiceSelect.value;
      const voices = speechSynthesis.getVoices();

      if (!voices.length) {
        console.error('No voices available. Retrying...');
        setTimeout(() => speak(text), 100);
        return;
      }

      console.log("Selected voice:", selectedVoiceName);
      console.log("Available voices:", voices.map(voice => voice.name));

      if (selectedVoiceName !== 'No Voice') {
        const voice = voices.find(voice => voice.name === selectedVoiceName);
        if (voice) {
          utterance.voice = voice;
        } else {
          console.error('Selected voice not found, using default voice.');
          utterance.voice = voices.find(voice => voice.name.includes('Microsoft Zira')) || voices[0];
        }
        console.log(`Using voice: ${utterance.voice ? utterance.voice.name : 'default voice'}`);
        isTTSActive = true;
        window.speechSynthesis.speak(utterance);
        currentUtterance = utterance;
        stopTTSBtn.disabled = false;
        statusDiv.innerText = "Speaking...";

        utterance.onend = () => {
          isTTSActive = false;
          currentUtterance = null;
          stopTTSBtn.disabled = true;
          statusDiv.innerText = "Speech synthesis ended.";
        };
      } else {
        console.log("TTS is turned off.");
        statusDiv.innerText = "TTS is turned off.";
      }
    }

    // Populate voice options in the dropdown
    function populateVoiceList() {
      const voices = speechSynthesis.getVoices();
      voiceSelect.innerHTML = '';
      const noVoiceOption = document.createElement('option');
      noVoiceOption.textContent = 'No Voice';
      noVoiceOption.value = 'No Voice';
      voiceSelect.appendChild(noVoiceOption);
      voices.forEach(voice => {
        const option = document.createElement('option');
        option.textContent = `${voice.name} (${voice.lang})`;
        option.value = voice.name;
        voiceSelect.appendChild(option);
      });
      console.log("Available voices:", voices.map(voice => voice.name));
      const savedVoice = localStorage.getItem('selectedVoice');
      if (savedVoice) {
        voiceSelect.value = savedVoice;
      } else {
        const defaultVoice = voices.find(voice => voice.name.includes('Microsoft Zira')) || voices[0];
        if (defaultVoice) {
          voiceSelect.value = defaultVoice.name;
        }
      }
    }

    // Save the selected voice to localStorage when the user changes selection
    voiceSelect.addEventListener('change', () => {
      const selectedVoice = voiceSelect.value;
      localStorage.setItem('selectedVoice', selectedVoice);
      console.log("Voice selection changed to:", selectedVoice);
    });

    // Initialize settings, voice list, and load models on page load
    window.onload = () => {
      loadSettings();
      populateVoiceList();
      loadModels();
      if (speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = populateVoiceList;
      }
      startBtn.disabled = false;
      statusDiv.innerText = "Ready for conversation.";
    };
  </script>
</body>
</html>
